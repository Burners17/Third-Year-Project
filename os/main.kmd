KMD
00000000:             ; ; This is the main program for the OS that brings together the kernal 
00000000:             ; ; and the moduls used to create the OS
00000000:             ; ; This is also where all example programs will be loaded to. 
00000000:             ; 
00000000:             ; GET kernal/kernal.s 
00000000: EA000006    ; B Initialise_Program  ; This Reset Exception
00000004: EAFFFFFE    ; Undefined_Instruction B Undefined_Instruction ; Undefined Instruction cause a branch to here
00000008: EA000016    ; B SVC_Handler         ; SVC calls jump to here and then go to the SVC Handler
0000000C: EAFFFFFE    ; Prefetch_Abort        B Prefetch_Abort ; If there is a Prefect Abort the PC come here
00000010: EAFFFFFE    ; Data_Abort            B Data_Abort     ; If there is a Data Abort the PC jump here
00000014: EAFFFFFE    ; Not_Provided_Except   B Not_Provided_Except ; Do not know why PC might jump here
00000018:             ; ; ---------------------------------------------------------
00000018:             ; ; Needs to be done
00000018: EA000013    ; B IRQ_Handler         ; If and Interupt occurs PC jumps here.
0000001C: EAFFFFFE    ; Fast_Interrupt_Request B Fast_Interrupt_Request ; If a Fast Interrupt occurs, PC jumps here
00000020:             ; 
00000020:             ; 
00000020:             ; Initialise_Program 
00000020:             ; ; code for setting up supervisor mode 
00000020: E28FD036    ;     ADRL  SP, Supervisor_Stack_End ; Sets up the Stack Pointer for Supervisor Mode
00000024: E28DDC03    ; 
00000028: EB000212    ;     BL StanIn_Initialise
0000002C:             ; ; code for setting up Interrupt mode 
0000002C:             ; ; Switch to Interrupt Mode
0000002C: E10F0000    ;     MRS R0, CPSR                      ; Read Current Status of CPSR
00000030: E3C0001F    ;     BIC R0, R0, #System_Mode_Bit_Mask ; Clears Mode field of CPSR
00000034: E3800012    ;     ORR R0, R0, #IRQ_Mode             ; Append IRQ Mode to CPSR
00000038: E121F000    ;     MSR CPSR_c, R0                    ; Updates the CPSR
0000003C:             ; 
0000003C:             ;     ; Set Interrupt Stack Pointer
0000003C: E28FD072    ;     ADRL SP, Interrupt_Stack_End      ; Sets up Interrupt Stack Pointer
00000040: E28DDC05    ; 
00000044:             ; 
00000044:             ; ; Deactivates all interrupt alerts execpt when input from serial - prevents problems later on.
00000044: E3A00201    ;     MOV     R0, #Base_Port_Area
00000048: E3A01000    ;     MOV R1, #0 
0000004C: E5C01018    ;     STRB R1, [R0, #Interrupt_Alert_Offset]  ; removes any existing alerts 
00000050: E3A01010    ;     MOV     R1, #0b0001_0000                ; Sets R2 to 0 so that all execpt rxD interrupts ar
                      ; e inactive
00000054: E5C0101C    ;     STRB    R1, [R0, #Interrupt_Active_Offset]  ; Disables all active Interrupts
00000058:             ; 
00000058:             ; ; code for setting up user mode 
00000058: E3A0E050    ;     MOV R14, #&50 ; CPSR for user mode with interrupts enabled
0000005C:             ;     ;BIC R14, R14, #CPSR_Interupt_Enabled ; Enables Interrupts
0000005C: E16FF00E    ;     MSR SPSR, R14                    ; Updates the CPSR
00000060: E59FE8D4    ;     LDR R14, =User_Code_start
00000064: E1B0F00E    ;     MOVS PC, R14
00000068:             ; 
00000068:             ; ; SVC call handeler code 
00000068:             ; ; get file 
00000068:             ; GET kernal_SVC_Handler.s 
00000068: EAFFFFFE    ; SVC_Handler  B SVC_Handler        ; SVC calls jump to here and then go to the SVC Handler
0000006C:             ; 
0000006C:             ; 
0000006C:             ; 
0000006C:             ; ; Interrupt handler 
0000006C:             ; ; get file 
0000006C:             ; GET kernal_IRQ_Handler.s 
0000006C:             ; ; currently set up for only possible interrupt
0000006C:             ; 
0000006C:             ; IRQ_Handler 
0000006C: E24EE004    ;     SUB LR, LR, #4 ; moves LR back one step so no need to sub when returning
00000070: E92D400F    ;     STMFD SP!, {R0-R3, LR} ; preserves registers
00000074:             ;     ; gets which interrupts were triggered 
00000074: E3A00201    ;     MOV R0, #Base_Port_Area 
00000078: E5D01018    ;     LDRB R1, [R0, #Interrupt_Alert_Offset]
0000007C: E2011010    ;     AND R1, R1, #Interrupt_Desired
00000080:             ; 
00000080:             ;     ; Check if serial ready to read is high 
00000080: E3110010    ;     TST R1, #&10
00000084: 1B000004    ;     BLNE IRQ_RxD
00000088:             ; 
00000088:             ;     ; Check if serial ready to write is high 
00000088: E3110020    ;     TST R1, #&20
0000008C: 1B000010    ;     BLNE IRQ_TxD    
00000090:             ; 
00000090:             ;     ; Check if time interrupt is high
00000090: E3110000    ;     TST R1, #&0
00000094: 1B00000F    ;     BLNE IRQ_Timer
00000098:             ; 
00000098:             ; ; Return to were interrupt occured 
00000098: E8FD800F    ;     LDMFD SP!, {R0-R3, PC}^
0000009C:             ; 
0000009C:             ; 
0000009C:             ; IRQ_RxD ; takes input and send it to the terminal
0000009C: E92D4000    ;     PUSH {LR}
000000A0: E3A02010    ;     MOV R2, #Terminal_Data
000000A4: E7903002    ;     LDR R3, [R0, R2] ; gets input from serial 
000000A8: E7803002    ;     STR R3, [R0, R2] ; places input on serial 
000000AC: E353000A    ;     CMP R3, #&A
000000B0: 0A000009    ;     BEQ empty
000000B4: E1A00003    ;     MOV R0, R3
000000B8: EB0001F5    ;     BL StandIn_Place
000000BC: E3500000    ;     CMP R0, #&0
000000C0: 0AFFFFFE    ; tempL    BEQ tempL
000000C4: E3A00201    ; MOV R0, #Base_Port_Area 
000000C8:             ; empty_return
000000C8: E3C11010    ;     BIC R1, R1, #0b0001_0000 ; clears serial RxD interrupt
000000CC: E5C01018    ;     STRB R1, [R0, #Interrupt_Alert_Offset]
000000D0: E8BD8000    ;     POP {PC}
000000D4:             ; 
000000D4:             ; IRQ_TxD 
000000D4:             ;     ; check if StandardOut has anything in its buffer 
000000D4:             ;     ; if so place into TxD until either buffer is empty or TxD is no longer ready 
000000D4:             ;     ; lower the TxD alert
000000D4: EAFFFFFE    ; B IRQ_TxD 
000000D8:             ; 
000000D8:             ; IRQ_Timer
000000D8:             ;     ; this is where timing interrupts are handled
000000D8:             ;     ; will be used to start context switch 
000000D8:             ; 
000000D8: EAFFFFE3    ; B IRQ_Handler 
000000DC:             ; 
000000DC:             ; 
000000DC:             ; empty 
000000DC: E92D001F    ;     PUSH {R0-R4}
000000E0:             ; empty_loop
000000E0: EB000204    ;     BL StandIn_Get
000000E4: E3A04201    ;     MOV R4, #Base_Port_Area 
000000E8: E3A02010    ;     MOV R2, #Terminal_Data
000000EC: E3510001    ;     CMP R1, #&1
000000F0: 07840002    ;     STREQ R0, [R4, R2] ; places input on serial 
000000F4: 13A0000A    ;     MOVNE R0, #&A
000000F8: 17840002    ;     STRNE R0, [R4, R2]
000000FC: 0AFFFFF7    ;     BEQ empty_loop
00000100: E8BD001F    ;     POP {R0-R4}
00000104: E24FF044    ;     ADR PC, empty_return
00000108:             ; 
00000108:             ; 
00000108:             ; Port_Area               EQU &1000_0000
00000108:             ; Terminal_Data           EQU &10
00000108:             ; Terminal_Control        EQU &14
00000108:             ; 
00000108:             ; ; Kernal Constants 
00000108:             ; GET kernal_constants.s
00000108:             ; ; Constants used by the kernal are define here for easy access and maintance 
00000108:             ; 
00000108:             ; ; Constants used for initialse and changing user mode
00000108:             ;     User_Mode   EQU &10         ; User Mode
00000108:             ;     IRQ_Mode    EQU &12         ; Interrupt Mode
00000108:             ;     System_Mode_Bit_Mask EQU &1F ; Used to clear the are that determines system mode
00000108:             ;     CPSR_Interupt_Enabled EQU 0b1000_0000   ; Bit responsible for whether or not Interrupts are
                      ;  Enabled
00000108:             ; 
00000108:             ; 
00000108:             ;     Base_Port_Area  EQU &10000000   ; Defines I/O Base port area
00000108:             ; 
00000108:             ;     Interrupt_Alert_Offset EQU &18
00000108:             ;     Interrupt_Active_Offset EQU &1C
00000108:             ;     Interrupt_Desired       EQU 0b0001_0000
00000108:             ; 
00000108:             ; ; kernal memory. 
00000108:             ; GET kernal_memory.s 
00000108:             ; ; Any predefine memory used by the kernal will be here for easy access
00000108:             ; 
00000108:             ; Supervisor_Stack_Size EQU &256
00000108:             ; Interrupt_Stack_Size  EQU &256
00000108:             ; StandardIn_Buffer_Size  EQU &256
00000108:             ; 
00000108:             ;                     Align     ; Just in case size is not in base 2
00000108:             ; ; Supervisor Stack
00000108:             ; Supervisor_Stack_Start  DEFS Supervisor_Stack_Size ; Supervisor Stack
0000035E:             ; Supervisor_Stack_End
0000035E:             ; 
00000360:             ;                     Align
00000360:             ; ; Interrupt Stack 
00000360:             ; Interrupt_Stack_Start   DEFS Interrupt_Stack_Size ; Interrupt Stack
000005B6:             ; Interrupt_Stack_End
000005B8:             ;                     Align
000005B8:             ; 
000005B8:             ; ; Standardin buffer #
000005B8:             ; 
000005B8:             ; StandardIn_Buffer_Head_Pointer DEFS &32
000005EA:             ; 
000005EC:             ; ALIGN
000005EC:             ; StandardIn_Buffer_Tail_Pointer DEFS &32
0000061E:             ; 
00000620:             ; ALIGN
00000620:             ; StandardIn_Buffer_Start DEFS StandardIn_Buffer_Size
00000876:             ; StandardIn_Buffer_End
00000876:             ; 
00000878:             ; ALIGN
00000878:             ; 
00000878:             ; ; sets up standard in buffer for use 
00000878:             ; StanIn_Initialise
00000878: E92D4003    ;     PUSH {R0-R1, LR}
0000087C: E24F0FB3    ;     ADRL R0, StandardIn_Buffer_Head_Pointer
00000880: E24F1F9A    ;     ADRL R1, StandardIn_Buffer_Start
00000884: E5001000    ;     STR  R1, [R0]
00000888: E24F0FA9    ;     ADRL R0, StandardIn_Buffer_Tail_Pointer
0000088C: E5001000    ;     STR  R1, [R0]
00000890: E8BD8003    ;     POP {R0-R1, PC}
00000894:             ; 
00000894:             ; 
00000894:             ; ; Place into buffer 
00000894:             ; ; input value come from R0 
00000894:             ; StandIn_Place 
00000894: E92D403E    ;     PUSH {R1-R5, LR}
00000898:             ;     ; get head and tail pointer locations 
00000898: E24F1FBA    ;     ADRL R1, StandardIn_Buffer_Head_Pointer
0000089C: E5114000    ;     LDR  R4, [R1]
000008A0: E24F1FAF    ;     ADRL R1, StandardIn_Buffer_Tail_Pointer
000008A4: E5115000    ;     LDR  R5, [R1]
000008A8:             ; 
000008A8:             ;     ; check to see if tail is on next location 
000008A8: E24F103A    ;     ADRL R1, StandardIn_Buffer_End
000008AC: E1540001    ;     CMP R4, R1
000008B0: 0A000008    ;     BEQ XXXXX
000008B4:             ;     ; Check to see if tail is in word below
000008B4: E2451004    ;     SUB R1, R5, #&4
000008B8: E1510004    ;     CMP R1, R4 
000008BC:             ;     ; if not equal it can place, otherwise place request fails 
000008BC: 15040000    ;     STRNE R0, [R4]
000008C0: 12844004    ;     ADDNE R4, R4, #&4
000008C4: 13A00001    ;     MOVNE R0, #&1
000008C8: 03A00000    ;     MOVEQ R0, #&0
000008CC: E24F1FC7    ;     ADRL R1, StandardIn_Buffer_Head_Pointer
000008D0: E5014000    ;     STR  R4, [R1]
000008D4: E8BD803E    ;     POP {R1-R5, PC}
000008D8:             ; 
000008D8:             ;     XXXXX ; means that head of tail is at the bottom 
000008D8:             ;     ; Check if tail it at top 
000008D8: E24F1D0B    ;     ADRL R1, StandardIn_Buffer_Start
000008DC: E1550001    ;     CMP R5, R1 
000008E0: 15040000    ;     STRNE R0, [R4]
000008E4: 13A00001    ;     MOVNE R0, #&1
000008E8: 03A00000    ;     MOVEQ R0, #&0
000008EC: E24F1FCF    ;     ADRL R1, StandardIn_Buffer_Head_Pointer
000008F0: E5014000    ;     STR  R4, [R1]
000008F4: E8BD803E    ;     POP {R1-R5, PC}
000008F8:             ; 
000008F8:             ; StandIn_Get
000008F8: E92D407C    ;     PUSH {R2-R6, LR}
000008FC:             ;     ; get head and tail pointer locations 
000008FC: E24F1FD3    ;     ADRL R1, StandardIn_Buffer_Head_Pointer
00000900: E5114000    ;     LDR  R4, [R1]
00000904: E24F1E32    ;     ADRL R1, StandardIn_Buffer_Tail_Pointer
00000908: E5115000    ;     LDR  R5, [R1]
0000090C:             ; 
0000090C: E1540005    ;     CMP R4, R5
00000910: 03A01000    ;     MOVEQ R1, #&0
00000914: 13A01001    ;     MOVNE R1, #&1
00000918: 15150000    ;     LDRNE R0, [R5]
0000091C: 12855004    ;     ADDNE R5, R5, #&4
00000920: E24F6FCF    ;     ADRL R6, StandardIn_Buffer_Tail_Pointer
00000924: E5065000    ;     STR  R5, [R6]
00000928: E8BD807C    ;     POP{R2-R6, PC}
0000092C:             ; 
0000092C:             ; 
0000092C:             ; 
0000092C:             ; 
0000092C:             ; User_Code_start
0000092C:             ; 
0000092C: E3A00000    ; MOV R0, #&0
00000930: E3A01001    ; MOV R1, #&1
00000934: E3A02002    ; MOV R2, #&2
00000938:             ; 
00000938:             ; End
00000938: EAFFFFFE    ; B End
0000093C: 0000092C    ; Remaining literals

Symbol Table: Labels
: Undefined_Instruction             00000004  Local -- ARM
: Prefetch_Abort                    0000000C  Local -- ARM
: Data_Abort                        00000010  Local -- ARM
: Not_Provided_Except               00000014  Local -- ARM
: Fast_Interrupt_Request            0000001C  Local -- ARM
: Initialise_Program                00000020  Local -- ARM
: SVC_Handler                       00000068  Local -- ARM
: IRQ_Handler                       0000006C  Local -- ARM
: IRQ_RxD                           0000009C  Local -- ARM
: tempL                             000000C0  Local -- ARM
: empty_return                      000000C8  Local -- ARM
: IRQ_TxD                           000000D4  Local -- ARM
: IRQ_Timer                         000000D8  Local -- ARM
: empty                             000000DC  Local -- ARM
: empty_loop                        000000E0  Local -- ARM
: Port_Area                         10000000  Value
: Terminal_Data                     00000010  Value
: Terminal_Control                  00000014  Value
: User_Mode                         00000010  Value
: IRQ_Mode                          00000012  Value
: System_Mode_Bit_Mask              0000001F  Value
: CPSR_Interupt_Enabled             00000080  Value
: Base_Port_Area                    10000000  Value
: Interrupt_Alert_Offset            00000018  Value
: Interrupt_Active_Offset           0000001C  Value
: Interrupt_Desired                 00000010  Value
: Supervisor_Stack_Size             00000256  Value
: Interrupt_Stack_Size              00000256  Value
: StandardIn_Buffer_Size            00000256  Value
: Supervisor_Stack_Start            00000108  Local -- ARM
: Supervisor_Stack_End              0000035E  Local -- ARM
: Interrupt_Stack_Start             00000360  Local -- ARM
: Interrupt_Stack_End               000005B6  Local -- ARM
: StandardIn_Buffer_Head_Pointer    000005B8  Local -- ARM
: StandardIn_Buffer_Tail_Pointer    000005EC  Local -- ARM
: StandardIn_Buffer_Start           00000620  Local -- ARM
: StandardIn_Buffer_End             00000876  Local -- ARM
: StanIn_Initialise                 00000878  Local -- ARM
: StandIn_Place                     00000894  Local -- ARM
: XXXXX                             000008D8  Local -- ARM
: StandIn_Get                       000008F8  Local -- ARM
: User_Code_start                   0000092C  Local -- ARM
: End                               00000938  Local -- ARM
