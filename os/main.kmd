KMD
00000000:             ; ; This is the main program for the OS that brings together the kernal 
00000000:             ; ; and the moduls used to create the OS
00000000:             ; ; This is also where all example programs will be loaded to. 
00000000:             ; 
00000000:             ; GET kernal/kernal.s 
00000000:             ; ; Main file of kernal 
00000000:             ; ;   Done 
00000000:             ; ; 
00000000:             ; ;   Needs to be done 
00000000:             ; ;   Clean up used registers 
00000000:             ; 
00000000:             ; 
00000000: EA000006    ; B Initialise_Program  ; This Reset Exception
00000004: EAFFFFFE    ; Undefined_Instruction B Undefined_Instruction ; Undefined Instruction cause a branch to here
00000008: EA000016    ; B SVC_Handler         ; SVC calls jump to here and then go to the SVC Handler
0000000C: EAFFFFFE    ; Prefetch_Abort        B Prefetch_Abort ; If there is a Prefect Abort the PC come here
00000010: EAFFFFFE    ; Data_Abort            B Data_Abort     ; If there is a Data Abort the PC jump here
00000014: EAFFFFFE    ; Not_Provided_Except   B Not_Provided_Except ; Do not know why PC might jump here
00000018:             ; ; ---------------------------------------------------------
00000018:             ; ; Needs to be done
00000018: EA000013    ; B IRQ_Handler         ; If and Interupt occurs PC jumps here.
0000001C: EAFFFFFE    ; Fast_Interrupt_Request B Fast_Interrupt_Request ; If a Fast Interrupt occurs, PC jumps here
00000020:             ; 
00000020:             ; 
00000020:             ; Initialise_Program 
00000020:             ; ; code for setting up supervisor mode 
00000020: E28FD002    ;     ADRL  SP, Supervisor_Stack_End ; Sets up the Stack Pointer for Supervisor Mode
00000024: E28DDB01    ; 
00000028: EB000030    ;     BL kernal_Initial
0000002C:             ; 
0000002C:             ; ;Deactivates all interrupt alerts execpt when input from serial - prevents problems later on.
0000002C: E3A00201    ;     MOV     R0, #Base_Port_Area
00000030: E3A01000    ;     MOV     R1, #0 
00000034: E5C01018    ;     STRB    R1, [R0, #Interrupt_Alert_Offset]  ; removes any existing alerts 
00000038: E3A01010    ;     MOV     R1, #0b0001_0000                ; Sets R2 to 0 so that all execpt rxD interrupts ar
                      ; e inactive
0000003C: E5C0101C    ;     STRB    R1, [R0, #Interrupt_Active_Offset]  ; Disables all active Interrupts
00000040:             ; 
00000040:             ; 
00000040:             ; ; Switch to Interrupt Mode
00000040: E10F0000    ;     MRS R0, CPSR                      ; Read Current Status of CPSR
00000044: E3C0001F    ;     BIC R0, R0, #System_Mode_Bit_Mask ; Clears Mode field of CPSR
00000048: E3800012    ;     ORR R0, R0, #IRQ_Mode             ; Append IRQ Mode to CPSR
0000004C: E121F000    ;     MSR CPSR_c, R0                    ; Updates the CPSR
00000050:             ; 
00000050:             ;     ; Set Interrupt Stack Pointer
00000050: E28FD02A    ;     ADRL SP, Interrupt_Stack_End      ; Sets up Interrupt Stack Pointer
00000054: E28DDC06    ; 
00000058:             ; 
00000058:             ; 
00000058:             ; ; code for setting up user mode 
00000058: E3A0E050    ;     MOV R14, #&50 ; CPSR for user mode with interrupts enabled
0000005C:             ;     ;BIC R14, R14, #CPSR_Interupt_Enabled ; Enables Interrupts
0000005C: E16FF00E    ;     MSR SPSR, R14                    ; Updates the CPSR
00000060: E59FE884    ;     LDR R14, =User_Code_start
00000064: E1B0F00E    ;     MOVS PC, R14
00000068:             ; 
00000068:             ; ; SVC call handeler code 
00000068:             ; ; get file 
00000068:             ; GET kernal_SVC_Handler.s 
00000068: EAFFFFFE    ; SVC_Handler  B SVC_Handler        ; SVC calls jump to here and then go to the SVC Handler
0000006C:             ; 
0000006C:             ; 
0000006C:             ; 
0000006C:             ; ; Interrupt handler 
0000006C:             ; ; get file 
0000006C:             ; GET kernal_IRQ_Handler.s 
0000006C:             ; ; currently set up for only possible interrupt
0000006C:             ; 
0000006C:             ; IRQ_Handler 
0000006C: E24EE004    ;     SUB LR, LR, #4 ; moves LR back one step so no need to sub when returning
00000070: E92D403F    ;     STMFD SP!, {R0-R5, LR} ; preserves registers
00000074:             ;     ; gets which interrupts were triggered 
00000074: E3A04201    ;     MOV R4, #Base_Port_Area 
00000078: E5D45018    ;     LDRB R5, [R4, #Interrupt_Alert_Offset]
0000007C: E2055010    ;     AND R5, R5, #Interrupt_Desired
00000080:             ; 
00000080:             ;     ; Check if serial ready to read is high 
00000080: E3150010    ;     TST R5, #&10
00000084: 1B000004    ;     BLNE IRQ_RxD
00000088:             ; 
00000088:             ;     ; Check if serial ready to write is high 
00000088: E3150020    ;     TST R5, #&20
0000008C: 1B000015    ;     BLNE IRQ_TxD    
00000090:             ; 
00000090:             ;     ; Check if time interrupt is high
00000090: E3150000    ;     TST R5, #&0
00000094: 1B000014    ;     BLNE IRQ_Timer
00000098:             ; 
00000098:             ; ; Return to were interrupt occured 
00000098: E8FD803F    ;     LDMFD SP!, {R0-R5, PC}^
0000009C:             ; 
0000009C:             ; IRQ_RxD ; interrupt from serial receiver 
0000009C: E92D4040    ;     PUSH    {R6, LR} 
000000A0: E3A06010    ;     MOV R6, #Terminal_Data
000000A4: E7941006    ;     LDR R1, [R4, R6] ; R4 comes from interrupt handler as a whole 
000000A8: E7841006    ;     STR R1, [R4, R6] ; 
000000AC:             ;     
000000AC:             ;     ;Code to empty buffer 
000000AC: E351000A    ;     CMP R1, #&A
000000B0: 0B000004    ;     BLEQ IRQ_RxD_empty 
000000B4:             ; 
000000B4: 128F0C01    ;     ADRNE     R0, StandardIn_Address
000000B8: 1B00001D    ;     BLNE      buffer_put
000000BC: E3C55010    ;     BIC R5, R5, #0b0001_0000 ; clears serial RxD interrupt
000000C0: E5C45018    ;     STRB R5, [R4, #Interrupt_Alert_Offset]
000000C4: E8BD8040    ;     POP     {R6, PC}
000000C8:             ; 
000000C8:             ; IRQ_RxD_empty 
000000C8: E92D4040    ;     PUSH    {R6, LR}
000000CC: E28F00E8    ;     ADR     R0, StandardIn_Address
000000D0:             ; IRQ_RxD_empty_loop
000000D0: E3A06010    ;     MOV R6, #Terminal_Data
000000D4: EB00002A    ;     BL      buffer_get
000000D8: E3510000    ;     CMP     R1, #&0
000000DC: 17841006    ;     STRNE   R1, [R4, R6]
000000E0: 1AFFFFFA    ;     BNE     IRQ_RxD_empty_loop
000000E4: E8BD4040    ;     POP     {R6, LR}
000000E8:             ; 
000000E8:             ; IRQ_TxD 
000000E8:             ;     ; check if StandardOut has anything in its buffer 
000000E8:             ;     ; if so place into TxD until either buffer is empty or TxD is no longer ready 
000000E8:             ;     ; lower the TxD alert
000000E8: EAFFFFFE    ; B IRQ_TxD 
000000EC:             ; 
000000EC:             ; IRQ_Timer
000000EC:             ;     ; this is where timing interrupts are handled
000000EC:             ;     ; will be used to start context switch 
000000EC:             ; 
000000EC: EAFFFFDE    ; B IRQ_Handler 
000000F0:             ; 
000000F0:             ; Port_Area               EQU &1000_0000
000000F0:             ; Terminal_Data           EQU &10
000000F0:             ; Terminal_Control        EQU &14
000000F0:             ; 
000000F0:             ; ; Kernal initialiser 
000000F0:             ; GET kernal_Initialise.s
000000F0:             ; 
000000F0:             ; ; set up standardIn buffer 
000000F0:             ; ; get address of reserved memory 
000000F0:             ; ; initalise buffer 
000000F0:             ; ; store buffer address 
000000F0:             ; kernal_Initial
000000F0: E92D4010    ;     PUSH    {R4, LR}
000000F4: E28F0F62    ;     ADRL     R0, StandardIn_start
000000F8: E2800B01    ; 
000000FC: E28F40B8    ;     ADRL     R4, StandardIn_Address
00000100:             ;     ; Stores starting address of StandardIn input a fixed place variable
00000100: E5040000    ;     STR     R0, [R4]
00000104:             ;     ; might be able to avoid by making StandardIn_Address EQU StandardIn_start
00000104: E3A01040    ;     MOV R1, #&40
00000108: EB000000    ;     BL      buffer_initialise
0000010C: E8BD8010    ;     POP     {R4, PC}
00000110:             ; 
00000110:             ; 
00000110:             ; ; Kernal Constants 
00000110:             ; GET kernal_constants.s
00000110:             ; ; Constants used by the kernal are define here for easy access and maintance 
00000110:             ; 
00000110:             ; ; Constants used for initialse and changing user mode
00000110:             ;     User_Mode   EQU &10         ; User Mode
00000110:             ;     IRQ_Mode    EQU &12         ; Interrupt Mode
00000110:             ;     System_Mode_Bit_Mask EQU &1F ; Used to clear the are that determines system mode
00000110:             ;     CPSR_Interupt_Enabled EQU 0b1000_0000   ; Bit responsible for whether or not Interrupts are
                      ;  Enabled
00000110:             ; 
00000110:             ; 
00000110:             ;     Base_Port_Area  EQU &10000000   ; Defines I/O Base port area
00000110:             ; 
00000110:             ;     Interrupt_Alert_Offset EQU &18
00000110:             ;     Interrupt_Active_Offset EQU &1C
00000110:             ;     Interrupt_Desired       EQU 0b0001_0000
00000110:             ; 
00000110:             ; ; Kernal data structurs 
00000110:             ; GET kernal_data_structures.s
00000110:             ; ; This file holds all the data structurs used by the OS 
00000110:             ; struct
00000110:             ; buffer_start    word 
00000110:             ; buffer_end      word 
00000110:             ; buffer_head     word
00000110:             ; buffer_tail     word 
00000110:             ; buffer_waiter   word
00000110:             ;     struct_align  
00000110:             ; 
00000110:             ; ; kernal buffer template 
00000110:             ; GET kernal_buffer.s
00000110:             ; ; Buffer calls template 
00000110:             ; 
00000110:             ; buffer_initialise
00000110:             ; ; takes as input 
00000110:             ; ;   R0 buffer starting address 
00000110:             ; ;   R1 buffer size in words
00000110:             ; ;   R2 buffer waiter if there is one
00000110:             ; ; important to note that the size of the buffer includes the 
00000110: E92D4010    ;     PUSH {R4, LR}
00000114: E2804014    ;     ADD R4, R0, #&14 ; this calculates the start of buffer memory 
00000118: E5804000    ;     STR R4, [R0, #buffer_start] ; stores start of buffer in start of buffer offset 
0000011C: E5804008    ;     STR R4, [R0, #buffer_head]
00000120: E580400C    ;     STR R4, [R0, #buffer_tail]
00000124: E5802010    ;     STR R2, [R0, #buffer_waiter]
00000128: E0804001    ;     ADD R4, R0, R1  
0000012C: E5804004    ;     STR R4, [R0, #buffer_end]
00000130: E8BD8010    ;     POP {R4, PC}
00000134:             ; 
00000134:             ; buffer_put
00000134:             ; ; inputs 
00000134:             ; ;   R0 buffer address 
00000134:             ; ;   R1 word to store
00000134:             ; ; outputs 
00000134:             ; ;   R0 success or failure 
00000134:             ; 
00000134:             ; ; register usage 
00000134:             ; ; internal variables R4-R7
00000134: E92D40F0    ;     PUSH {R4-R7, LR}
00000138:             ;     ; check if buffer is full 
00000138:             ;         ; check if head is 1 WORD ahead of tail 
00000138: E5904008    ;         LDR R4, [R0, #buffer_head]
0000013C: E590500C    ;         LDR R5, [R0, #buffer_tail]
00000140:             ;         ; checks if head is 1 word infront of tail 
00000140: E2856004    ;         ADD R6, R5, #&4
00000144: E1560004    ;         CMP R6, R4
00000148: 0A00000B    ;         BEQ buffer_full
0000014C:             ; 
0000014C:             ;         ; check if tail is at bottom of buffer and if so if tail is at base 
0000014C: E5906004    ;         LDR R6, [R0, #buffer_end]
00000150: E1560005    ;         CMP R6, R5
00000154: 05907000    ;         LDREQ R7, [R0, #buffer_start]
00000158: 01540007    ;         CMPEQ R4, R7 
0000015C: 0A000006    ;         BEQ buffer_full 
00000160:             ; 
00000160:             ;     ; place in buffer 
00000160: E5051000    ;         STR R1, [R5]
00000164:             ;         ; if tail is at bottom of register move to top 
00000164: E1560005    ;         CMP R6, R5 
00000168: 05905000    ;         LDREQ R5, [R0, #buffer_start] ; 
0000016C:             ;         ; else add 4 
0000016C: 12855004    ;         ADDNE R5, R5, #&4
00000170:             ;         ; and save new tail pointer address 
00000170: E580500C    ;         STR R5, [R0, #buffer_tail]
00000174:             ;         ; indicate sucess 
00000174: E3A00001    ;         MOV R0, #&1 
00000178: E8BD80F0    ;         POP {R4-R7, PC}
0000017C:             ; 
0000017C:             ; buffer_full
0000017C:             ;     ; indicate failure 
0000017C: E3A00000    ;     MOV R0, #&0
00000180: E8BD80F0    ;     POP {R4-R7, PC}
00000184:             ; 
00000184:             ; buffer_get 
00000184:             ; ; Inputs 
00000184:             ; ;   R0, Buffer address 
00000184:             ; ; Outputs 
00000184:             ; ;   R1, retrieved word 
00000184: E92D4070    ;     PUSH {R4-R6, LR}
00000188: E5904008    ;     LDR R4, [R0, #buffer_head]
0000018C: E590500C    ;     LDR R5, [R0, #buffer_tail]
00000190:             ;     
00000190:             ;     ; check if empty 
00000190: E1540005    ;     CMP R4, R5
00000194: 0A000006    ;     BEQ buffer_empty 
00000198:             ; 
00000198:             ;     ; if not retrieve word 
00000198: E5141000    ;     LDR R1, [R4]
0000019C:             ; 
0000019C:             ;     ; check if head is at bottom of buffer 
0000019C: E5906004    ;     LDR R6, [R0, #buffer_end]
000001A0: E1540006    ;     CMP R4, R6 
000001A4:             ;     ; if at bottom load buffer start address into register holding buffer head pointer 
000001A4: 05904000    ;     LDREQ R4, [R0, #buffer_start]
000001A8: 12844004    ;     ADDNE R4, R4, #&4
000001AC: E5804008    ;     STR R4, [R0, #buffer_head]
000001B0: E8BD8070    ;     POP {R4-R6, PC}
000001B4:             ; 
000001B4:             ; buffer_empty 
000001B4: E3A01000    ;     MOV R1, #&0
000001B8: E8BD8070    ;     POP {R4-R6, PC}
000001BC:             ; 
000001BC:             ; 
000001BC:             ; ; kernal memory. 
000001BC:             ; GET kernal_memory.s 
000001BC:             ; ; Any predefine memory used by the kernal will be here for easy access
000001BC:             ; 
000001BC:             ; ; Varibles 
000001BC:             ;     ; stores address of StandardIn Buffer 
000001BC:             ;     StandardIn_Address DEFS &16
000001D4:             ;         Align 
000001D4:             ; 
000001D4:             ; ; Blocks of memeory 
000001D4:             ;     ; Stacks 
000001D4:             ;         Supervisor_Stack_Size EQU &256
000001D4:             ;         Interrupt_Stack_Size  EQU &256
000001D4:             ;         StandardIn_Buffer_Size  EQU &256
000001D4:             ;             Align     ; Just in case size is not in base 2
000001D4:             ; 
000001D4:             ;         ; Supervisor Stack
000001D4:             ;         Supervisor_Stack_Start  DEFS Supervisor_Stack_Size ; Supervisor Stack
0000042A:             ;         Supervisor_Stack_End
0000042C:             ;             Align
0000042C:             ; 
0000042C:             ;         ; Interrupt Stack 
0000042C:             ;         Interrupt_Stack_Start   DEFS Interrupt_Stack_Size ; Interrupt Stack
00000682:             ;         Interrupt_Stack_End
00000684:             ;              Align
00000684:             ; 
00000684:             ;     ; Buffers 
00000684:             ;         StandardIn_start DEFS StandardIn_Buffer_Size
000008DA:             ;         StandardIn_End 
000008DC:             ;             Align 
000008DC:             ; 
000008DC:             ; User_Code_start
000008DC:             ; 
000008DC: E3A00000    ; MOV R0, #&0
000008E0: E3A01001    ; MOV R1, #&1
000008E4: E3A02002    ; MOV R2, #&2
000008E8:             ; 
000008E8:             ; End
000008E8: EAFFFFFE    ; B End
000008EC: 000008DC    ; Remaining literals

Symbol Table: Labels
: Undefined_Instruction             00000004  Local -- ARM
: Prefetch_Abort                    0000000C  Local -- ARM
: Data_Abort                        00000010  Local -- ARM
: Not_Provided_Except               00000014  Local -- ARM
: Fast_Interrupt_Request            0000001C  Local -- ARM
: Initialise_Program                00000020  Local -- ARM
: SVC_Handler                       00000068  Local -- ARM
: IRQ_Handler                       0000006C  Local -- ARM
: IRQ_RxD                           0000009C  Local -- ARM
: IRQ_RxD_empty                     000000C8  Local -- ARM
: IRQ_RxD_empty_loop                000000D0  Local -- ARM
: IRQ_TxD                           000000E8  Local -- ARM
: IRQ_Timer                         000000EC  Local -- ARM
: Port_Area                         10000000  Value
: Terminal_Data                     00000010  Value
: Terminal_Control                  00000014  Value
: kernal_Initial                    000000F0  Local -- ARM
: User_Mode                         00000010  Value
: IRQ_Mode                          00000012  Value
: System_Mode_Bit_Mask              0000001F  Value
: CPSR_Interupt_Enabled             00000080  Value
: Base_Port_Area                    10000000  Value
: Interrupt_Alert_Offset            00000018  Value
: Interrupt_Active_Offset           0000001C  Value
: Interrupt_Desired                 00000010  Value
: buffer_start                      00000000  Offset
: buffer_end                        00000004  Offset
: buffer_head                       00000008  Offset
: buffer_tail                       0000000C  Offset
: buffer_waiter                     00000010  Offset
: buffer_initialise                 00000110  Local -- ARM
: buffer_put                        00000134  Local -- ARM
: buffer_full                       0000017C  Local -- ARM
: buffer_get                        00000184  Local -- ARM
: buffer_empty                      000001B4  Local -- ARM
: StandardIn_Address                000001BC  Local -- ARM
: Supervisor_Stack_Size             00000256  Value
: Interrupt_Stack_Size              00000256  Value
: StandardIn_Buffer_Size            00000256  Value
: Supervisor_Stack_Start            000001D4  Local -- ARM
: Supervisor_Stack_End              0000042A  Local -- ARM
: Interrupt_Stack_Start             0000042C  Local -- ARM
: Interrupt_Stack_End               00000682  Local -- ARM
: StandardIn_start                  00000684  Local -- ARM
: StandardIn_End                    000008DA  Local -- ARM
: User_Code_start                   000008DC  Local -- ARM
: End                               000008E8  Local -- ARM
