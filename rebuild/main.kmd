KMD
00000000:             ; ; This file is the main for the whole OS
00000000:             ; 
00000000:             ; GET Kernal_Files/kernal.s
00000000:             ; ; This file is the main for the kernal 
00000000:             ; 
00000000: EA000006    ; B Initialise_Program  ; This Reset Exception
00000004: EAFFFFFE    ; Undefined_Instruction B Undefined_Instruction ; Undefined Instruction cause a branch to here
00000008: EA000005    ; B SVC_Handler         ; SVC calls jump to here and then go to the SVC Handler
0000000C: EAFFFFFE    ; Prefetch_Abort        B Prefetch_Abort ; If there is a Prefect Abort the PC come here
00000010: EAFFFFFE    ; Data_Abort            B Data_Abort     ; If there is a Data Abort the PC jump here
00000014: EAFFFFFE    ; Not_Provided_Except   B Not_Provided_Except ; Do not know why PC might jump here
00000018:             ; ; ---------------------------------------------------------
00000018:             ; ; Needs to be done
00000018: EA00000E    ; B IRQ_Handler         ; If and Interupt occurs PC jumps here.
0000001C: EAFFFFFE    ; Fast_Interrupt_Request B Fast_Interrupt_Request ; If a Fast Interrupt occurs, PC jumps here
00000020:             ; 
00000020:             ; Initialise_Program
00000020: EA00001C    ; B kernal_Initialise
00000024:             ; 
00000024:             ; GET     kernal_SVC_Handler.s
00000024: E92D4030    ; SVC_Handler PUSH  {R4-R5, LR}
00000028: E51E4004    ;             LDR   R4, [LR, #-4] ; Read the SVC Instruction from the LR
0000002C: E3C444FF    ;             BIC   R4, R4, #&FF000000 ; Masks off the Operation Code from SVC Call
00000030: E3540008    ;             CMP   R4, #SVC_Jump_Table_Size ; Checks that the Operation Code is defined.
00000034: 8A000006    ;             BHI   SVC_Out_Of_Bounds   ; Jumps to this Location If the SVC Calls is out of bound
                      ; s
00000038: E28F500C    ;             ADR   R5, SVC_Jump_Table  ; Loads SCV Jump Table Start Address into R5
0000003C: E28FE000    ;             ADD   LR, PC, #&0         ; Loads LR with end of handler, which handles return to S
                      ; VC Calls
00000040: E795F004    ;             LDR   PC, [R5, R4]        ; Loads the PC with the address of the function being cal
                      ; led
00000044: E8BD4030    ;             POP   {R4-R5, LR}         ; Restores Registers and Loads Return Address into LR
00000048: E1B0F00E    ;             MOVS  PC, LR              ; Restores CSPR code and moves PC to call address
0000004C:             ; 
0000004C:             ; SVC_Jump_Table_Size EQU SVC_Jump_Table_End - SVC_Jump_Table
0000004C: 00000AAC    ; SVC_Jump_Table      DEFW Interrupt_Set
00000050: 00000AC0    ;                     DEFW Interrupt_Off
00000054:             ;                     ;DEFW Initialise_Process
00000054:             ;                     ;DEFW Initialise_Process_Return
00000054:             ; SVC_Jump_Table_End
00000054:             ; 
00000054:             ; SVC_Jump_Table_place_holder
00000054:             ; 
00000054:             ; ; SVC Call Out of Bounds
00000054: EAFFFFFE    ; SVC_Out_Of_Bounds   B   SVC_Out_Of_Bounds ; SVC call out of bounds
00000058:             ; GET     kernal_IRQ_Handler.s
00000058:             ; ; Interrupt handler 
00000058:             ; IRQ_Handler 
00000058: E24EE004    ;     SUB     LR, LR, #4 ; moves LR back one step so no need to sub when returning
0000005C: E92D4030    ;     PUSH    {R4-R5, LR} ; preserves registers
00000060:             ; 
00000060:             ;     ; Find which interrupts where triggered 
00000060: E3A04201    ;     MOV     R4, #Port_Area 
00000064: E5D45018    ;     LDRB    R5, [R4, #Interrupt_Alert_Offset]
00000068:             ;     ;AND     R5, R5, #Interrupt_Desired
00000068:             ; 
00000068:             ;     ; Check if serial ready to read is high 
00000068: E3150010    ;     TST R5, #&10
0000006C: 1BFFFFFF    ;     BLNE IRQ_RxD
00000070:             ; 
00000070:             ; IRQ_RxD ; interrupt from serial receiver 
00000070: E92D400F    ;     PUSH    {R0-R3, LR} 
00000074: E3A03010    ;     MOV     R3, #Terminal_Data
00000078: E7941003    ;     LDR     R1, [R4, R3] ; R4 comes from interrupt handler as a whole 
0000007C: E7841003    ;     STR     R1, [R4, R3] ; 
00000080:             ;     
00000080: E28F0098    ;     ADR     R0, Serial_RxD_Buffer_Address
00000084: E5100000    ;     LDR     R0, [R0]
00000088: EB0002AA    ;     BL      buffer_put
0000008C: E3C55010    ;     BIC     R5, R5, #0b0001_0000 ; clears serial RxD interrupt
00000090: E5C45018    ;     STRB    R5, [R4, #Interrupt_Alert_Offset]
00000094: E8BD800F    ;     POP     {R0-R3, PC}
00000098:             ; 
00000098:             ; 
00000098:             ; 
00000098:             ; ; Loads the Kernal_Initialise code 
00000098:             ; GET     kernal_Initialise.s
00000098:             ; ; This program will set up the Operating systems 
00000098:             ; ; It will 
00000098:             ; ;   Set up Supervisor mode
00000098:             ; ;       Set Stack pointer  
00000098:             ; ;   Set up Interrupt mode 
00000098:             ; ;       Set up anything required by the interrupts 
00000098:             ; ;       Set Stack pointer
00000098:             ; 
00000098:             ; kernal_Initialise
00000098:             ; 
00000098:             ; ; Set up Supervisor 
00000098:             ;  ; Set up Stack pointer 
00000098: E28FD002    ;   ADRL    SP, Supervisor_Stack_End
0000009C: E28DDC03    ; 
000000A0:             ; 
000000A0:             ; ; Set up Interrupt Mode 
000000A0:             ;  ; Set up anything required or used by interrupts 
000000A0:             ;   ; RxD Interrupt 
000000A0:             ;    ; This interrupt requires a buffer to place things into 
000000A0:             ;     ; Get address of buffer and store it in a know variable 
000000A0: E28F0F55    ;     ADRL    R0, Serial_RxD_Buffer_Start
000000A4: E2800B01    ; 
000000A8: E28F1070    ;     ADRL    R1, Serial_RxD_Buffer_Address
000000AC: E5010000    ;     STR     R0, [R1]
000000B0:             ;     ; Initialise the buffer 
000000B0: E3A01040    ;     MOV     R1, #&40
000000B4: EB000296    ;     BL      buffer_initialise
000000B8: E3A01005    ;     MOV     R1, #5
000000BC: EB00029D    ;     BL      buffer_put
000000C0: E3A01000    ;     MOV     R1, #0 
000000C4: EB0002AD    ;     BL      buffer_get        
000000C8:             ;     
000000C8:             ;   ; TxD Interrupt 
000000C8:             ;    ; Buffer it uses
000000C8:             ;     ; Get address of buffer and store it in a know variable 
000000C8: E28F0FE1    ;     ADRL    R0, Serial_TxD_Buffer_Start
000000CC: E2800B01    ; 
000000D0: E28F105E    ;     ADRL    R1, Serial_TxD_Buffer_Address
000000D4: E5010000    ;     STR     R0, [R1]
000000D8:             ;     ; Initialise the buffer 
000000D8: E3A01040    ;     MOV       R1, #&40
000000DC: EB00028C    ;     BL        buffer_initialise   
000000E0:             ;   ; 
000000E0:             ;   ; Timer Interrupt 
000000E0:             ;   ; NA 
000000E0:             ; ; Switch Mode to Interupt mode 
000000E0: E10F0000    ;     MRS     R0, CPSR                      ; Read Current Status of CPSR
000000E4: E3C0001F    ;     BIC     R0, R0, #System_Mode_Bit_Mask ; Clears Mode field of CPSR
000000E8: E3800012    ;     ORR     R0, R0, #IRQ_Mode             ; Append IRQ Mode to CPSR
000000EC: E121F000    ;     MSR     CPSR_c, R0                    ; Updates the CPSR
000000F0:             ;  ;
000000F0:             ;  ; Set up Interrupt Stack Pointer
000000F0: E28FD002    ;     ADRL    SP, Interrupt_Stack_End      ; Sets up Interrupt Stack Pointer
000000F4: E28DDC05    ; 
000000F8:             ; 
000000F8:             ; ; Most likely redundant
000000F8:             ;  ; Return to Supervisor Mode 
000000F8: E10F0000    ;     MRS     R0, CPSR                      ; Read Current Status of CPSR
000000FC: E3C0001F    ;     BIC     R0, R0, #System_Mode_Bit_Mask ; Clears Mode field of CPSR
00000100: E3800013    ;     ORR     R0, R0, #Super_Mode           ; Append Supervisor Mode to CPSR
00000104: E121F000    ;     MSR     CPSR_c, R0                    ; Updates the CPSR
00000108:             ;  ;
00000108:             ; ;
00000108:             ; ; Initialise first process which is always terminal handler 
00000108: E28F0FA9    ;    ADRL     R0, Terminal_Handler_Process
0000010C: E2800B02    ; 
00000110: E590E00C    ;    LDR      R14, [R0, #process_constructor]
00000114: E3A00050    ;    MOV      R0, #&50
00000118: E16FF000    ;    MSR      SPSR, R0 
0000011C: E1B0F00E    ;    MOVS     PC, R14 
00000120:             ; 
00000120:             ; ; Loads Kernal Constants 
00000120:             ; GET     kernal_constants.s 
00000120:             ; ; This file holds all of the constants used by the kernal
00000120:             ; ; Constants for diffe
00000120:             ; IRQ_Mode                    EQU &12         ; Interrupt Mode
00000120:             ; Super_Mode                  EQU &13         ; Supervisor Mode
00000120:             ; System_Mode_Bit_Mask        EQU &1F ; Used to clear the are that determines system mode
00000120:             ; Interrupt_Receiver          EQU 0b0001_0000
00000120:             ; Interrupt_Transmit          EQU 0b0010_0000
00000120:             ; Interrupt_Alert_Offset      EQU &18
00000120:             ; Port_Area                   EQU &10000000
00000120:             ; Interrupt_Active_Offset     EQU &1C
00000120:             ; Interrupt_Receiver          EQU 0b0001_0000
00000120:             ; 
00000120:             ; 
00000120:             ; ; Loads Kernal Variables 
00000120:             ; GET     kernal_variables.s
00000120:             ; ; This file holds all the variables used by the kernal
00000120:             ; Serial_RxD_Buffer_Address DEFS &16
00000136:             ; Serial_TxD_Buffer_Address DEFS &16
0000014C:             ; 
0000014C:             ; ; Loads kernal predefined memeory 
0000014C:             ; GET     kernal_memory.s
0000014C:             ; ; This file includes all predefined memory used by the kernal 
0000014C:             ; 
0000014C:             ; ; Stacks 
0000014C:             ;     Supervisor_Stack_Size   EQU &256
0000014C:             ;     Interrupt_Stack_Size    EQU &256 
0000014C:             ;         Align 
0000014C:             ;     ; Supervisor Stack
0000014C:             ;     Supervisor_Stack_Start  DEFS Supervisor_Stack_Size ; Supervisor Stack
000003A2:             ;     Supervisor_Stack_End
000003A4:             ;         Align
000003A4:             ;     ; Interrupt Stack 
000003A4:             ;     Interrupt_Stack_Start   DEFS Interrupt_Stack_Size ; Interrupt Stack
000005FA:             ;     Interrupt_Stack_End
000005FC:             ;         Align
000005FC:             ; ; Buffers 
000005FC:             ;     Serial_RxD_Buffer_Size  EQU &256
000005FC:             ;         Align 
000005FC:             ;     Serial_TxD_Buffer_Size  EQU &256
000005FC:             ;         Align 
000005FC:             ; 
000005FC:             ;     Serial_RxD_Buffer_Start DEFS Serial_RxD_Buffer_Size
00000852:             ;     Serial_RxD_Buffer_End
00000854:             ;         Align 
00000854:             ; 
00000854:             ;     Serial_TxD_Buffer_Start DEFS Serial_TxD_Buffer_Size
00000AAA:             ;     Serial_TxD_Buffer_End
00000AAC:             ;         Align
00000AAC:             ; 
00000AAC:             ; GET     Kernal_Subroutines/Subroutines_main.s 
00000AAC:             ; 
00000AAC:             ; GET Setting_Interrupts.s
00000AAC:             ; Interrupt_Set 
00000AAC:             ; ; this sets the desired interrupt 
00000AAC:             ;       ; Enable the desired Interrupts, do not affect other Enabled Interrupts
00000AAC: E3A01201    ;     MOV     R1, #Port_Area
00000AB0: E5D1201C    ;     LDRB    R2, [R1, #Interrupt_Active_Offset]
00000AB4: E1810000    ;     ORR     R0, R1, R0 ; Enables the desired interrupts without touching those already set
00000AB8: E5C1001C    ;     STRB    R0, [R1, #Interrupt_Active_Offset]  ; memory location of enabled interrupts
00000ABC: E1A0F00E    ;     MOV     PC, LR
00000AC0:             ; 
00000AC0:             ; Interrupt_Off 
00000AC0:             ; ; this removes the desired interrupt 
00000AC0: E3A01201    ;     MOV     R1, #Port_Area
00000AC4: E5D1201C    ;     LDRB    R2, [R1, #Interrupt_Active_Offset]
00000AC8: E1C10000    ;     BIC     R0, R1, R0 ; Enables the desired interrupts without touching those already set
00000ACC: E5C1001C    ;     STRB    R0, [R1, #Interrupt_Active_Offset]  ; memory location of enabled interrupts
00000AD0: E1A0F00E    ;     MOV     PC, LR
00000AD4:             ; 
00000AD4:             ; 
00000AD4:             ; GET Transmit.s
00000AD4:             ; ; This SVC will send what is requested to Serial Transmitter 
00000AD4:             ; ; 
00000AD4:             ; 
00000AD4:             ; ; load control to see if transmitter internal buffer is full 
00000AD4:             ; 
00000AD4:             ; Transmit_word 
00000AD4: E92D407E    ;     PUSH    {R1-R6, LR} 
00000AD8: E3A05201    ;     MOV     R5, #Port_Area
00000ADC: E3A06014    ;     MOV     R6, #Terminal_Control
00000AE0: E7951006    ;     LDR     R1, [R5, R6] 
00000AE4: E3110002    ;     TST     R1, #2
00000AE8:             ;    ; if EQ then hardware buffer is full 
00000AE8: 1A000006    ;     BNE     Transmit_word_send
00000AEC: E1A01000    ;     MOV     R1, R0 
00000AF0: E24F00C2    ;     ADRL    R0, Serial_TxD_Buffer_Address
00000AF4: E2400C09    ; 
00000AF8: EB00000E    ;     BL      buffer_put
00000AFC: E3A00020    ;     MOV     R0, #Interrupt_Transmit 
00000B00: EBFFFFE9    ;     BL      Interrupt_Set    
00000B04: E8BD807E    ;     POP     {R1-R6, PC} 
00000B08:             ; 
00000B08:             ; Transmit_word_send
00000B08: E3A06010    ;     MOV     R6, #Terminal_Data
00000B0C: E7850006    ;     STR     R0, [R5, R6]
00000B10: E8BD807E    ;     POP     {R1-R6, PC}     
00000B14:             ; ; if full place on buffer 
00000B14:             ; ; activate interrupt
00000B14:             ; 
00000B14:             ; 
00000B14:             ;  
00000B14:             ; 
00000B14:             ; 
00000B14:             ; GET universal/universal_main.s
00000B14:             ; ; This file is used to enable an easy load of all universal files
00000B14:             ; 
00000B14:             ; GET universal_constants.s 
00000B14:             ; ; Constants used by all modes
00000B14:             ; 
00000B14:             ; ; SVC Codes
00000B14:             ; Interrupt_Set_SVC       EQU &0 
00000B14:             ; Interrupt_Off_SVC       EQU &4
00000B14:             ; ;EQU &0 
00000B14:             ; ;EQU &4
00000B14:             ; ;EQU &8
00000B14:             ; ;EQU &C 
00000B14:             ; ;EQU &10
00000B14:             ; ;EQU &14
00000B14:             ; 
00000B14:             ; 
00000B14:             ; Terminal_Data           EQU &10
00000B14:             ; Terminal_Control        EQU &14
00000B14:             ; 
00000B14:             ; GET data_structures/buffer.s
00000B14:             ; ; Buffer Data Structure 
00000B14:             ; ; Place in tail 
00000B14:             ; ; Retriveve from head
00000B14:             ; struct
00000B14:             ; buffer_start    word 
00000B14:             ; buffer_end      word 
00000B14:             ; buffer_head     word
00000B14:             ; buffer_tail     word 
00000B14:             ; buffer_waiter   word
00000B14:             ;     struct_align  
00000B14:             ; 
00000B14:             ; ; Functions 
00000B14:             ; ; Initialise Buffer 
00000B14:             ; buffer_initialise
00000B14:             ; ; This function intialises a buffer data structure 
00000B14:             ; ; Inputs 
00000B14:             ; ;   R0 buffer starting address 
00000B14:             ; ;   R1 buffer size in words 
00000B14:             ; ;   
00000B14: E92D4010    ;     PUSH    {R4, LR}
00000B18: E2804014    ;     ADD     R4, R0, #&14 ; this calculates the start of buffer memory 
00000B1C: E5804000    ;     STR     R4, [R0, #buffer_start] ; stores start of buffer in start of buffer offset 
00000B20: E5804008    ;     STR     R4, [R0, #buffer_head]
00000B24: E580400C    ;     STR     R4, [R0, #buffer_tail]
00000B28: E5802010    ;     STR     R2, [R0, #buffer_waiter]
00000B2C: E0804001    ;     ADD     R4, R0, R1  
00000B30: E5804004    ;     STR     R4, [R0, #buffer_end]
00000B34: E8BD8010    ;     POP     {R4, PC}
00000B38:             ; 
00000B38:             ; ; Place into buffer
00000B38:             ; buffer_put 
00000B38:             ; ; This function places a word into the buffer 
00000B38:             ; ; Inputs 
00000B38:             ; ;   R0 Address of where the buffer starts 
00000B38:             ; ;   R1 Word to store 
00000B38:             ; 
00000B38: E92D40F0    ;     PUSH    {R4-R7, LR}
00000B3C: E5904008    ;     LDR     R4, [R0, #buffer_head]
00000B40: E590500C    ;     LDR     R5, [R0, #buffer_tail] 
00000B44:             ; ;   Check if buffer is full 
00000B44:             ; ;       Check if head is 1 word infront of tail 
00000B44: E2856004    ;     ADD     R6, R5, #&4
00000B48: E1560004    ;     CMP     R6, R4
00000B4C: 0A00000A    ;     BEQ     buffer_full
00000B50:             ; ;       check if tail is at bottom of buffer and if so if tail is at base 
00000B50: E5906004    ;     LDR     R6, [R0, #buffer_end]
00000B54: E1560005    ;     CMP     R6, R5
00000B58: 05907000    ;     LDREQ   R7, [R0, #buffer_start]
00000B5C: 01540007    ;     CMPEQ   R4, R7 
00000B60: 0A000005    ;     BEQ     buffer_full 
00000B64:             ; 
00000B64:             ; ;   place in buffer 
00000B64: E5051000    ;     STR     R1, [R5]
00000B68:             ;     ; if tail is at bottom of register move to top 
00000B68: E1560005    ;     CMP     R6, R5 
00000B6C: 05905000    ;     LDREQ   R5, [R0, #buffer_start] ; 
00000B70:             ;     ; else add 4 
00000B70: 12855004    ;     ADDNE   R5, R5, #&4
00000B74:             ;     ; and save new tail pointer address 
00000B74: E580500C    ;     STR     R5, [R0, #buffer_tail]
00000B78: E8BD80F0    ;     POP     {R4-R7, PC}
00000B7C:             ; 
00000B7C:             ; ;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
00000B7C:             ; buffer_full
00000B7C: EAFFFFFE    ; B buffer_full
00000B80:             ; 
00000B80:             ; buffer_get 
00000B80:             ; ; This function retrieves a word from the buffer 
00000B80:             ; ; Inputs 
00000B80:             ; ;   R0 Address of where the buffer starts 
00000B80:             ; ; Outputs 
00000B80:             ; ;   R1 Word retrieved 
00000B80: E92D4070    ;     PUSH    {R4-R6, LR}
00000B84: E5904008    ;     LDR     R4, [R0, #buffer_head]
00000B88: E590500C    ;     LDR     R5, [R0, #buffer_tail]  
00000B8C:             ; 
00000B8C:             ;     ; Check if buffer is empty 
00000B8C: E1540005    ;     CMP     R4, R5 
00000B90: 0A000006    ;     BEQ     buffer_empty 
00000B94:             ; 
00000B94:             ;  ; if not retrieve word 
00000B94: E5141000    ;     LDR     R1, [R4]
00000B98:             ; 
00000B98:             ;     ; check if head is at bottom of buffer 
00000B98: E5906004    ;     LDR     R6, [R0, #buffer_end]
00000B9C: E1540006    ;     CMP     R4, R6 
00000BA0:             ;     ; if at bottom load buffer start address into register holding buffer head pointer 
00000BA0: 05904000    ;     LDREQ   R4, [R0, #buffer_start]
00000BA4: 12844004    ;     ADDNE   R4, R4, #&4
00000BA8: E5804008    ;     STR     R4, [R0, #buffer_head]
00000BAC: E8BD8070    ;     POP     {R4-R6, PC}
00000BB0:             ; 
00000BB0:             ; 
00000BB0:             ; ; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
00000BB0:             ; buffer_empty 
00000BB0: EAFFFFFE    ; B buffer_empty
00000BB4:             ; 
00000BB4:             ; GET data_structures/process.s
00000BB4:             ; ; Data Structure called processes 
00000BB4:             ; struct 
00000BB4:             ; pointer_next           word 
00000BB4:             ; process_id             word 
00000BB4:             ; process_stack_pointer  word 
00000BB4:             ; process_constructor    word
00000BB4:             ;     struct_align
00000BB4:             ; 
00000BB4:             ; 
00000BB4:             ; GET process_list.s
00000BB4:             ; ; List of all Processes 
00000BB4:             ; Terminal_Handler_Process
00000BB4: 00000000    ;     DEFW 0 
00000BB8: 00000001    ;     DEFW 1
00000BBC: 00000000    ;     DEFW 0 
00000BC0: 00000BC4    ;     DEFW Terminal_Handler_Constructor
00000BC4:             ; 
00000BC4:             ; Get user/user_main.s
00000BC4:             ; ; File to make it easy to load all user files 
00000BC4:             ; 
00000BC4:             ; ; Terminal Handler 
00000BC4:             ; GET Terminal_Handler.s
00000BC4:             ; ; Terminal Handler Process 
00000BC4:             ; ; This process handles intake from the terminal and determines how to respond
00000BC4:             ; 
00000BC4:             ; ;   Register Index 
00000BC4:             ;     ; R10 is used to tell the process if it an echo input or not 1 is echo 0 is not echo 
00000BC4:             ;     ; R11 is used to store address of RxD buffer start  
00000BC4:             ;     ; R12 is used to store address of buffer start 
00000BC4:             ; 
00000BC4:             ; 
00000BC4:             ; Terminal_Handler_Constructor
00000BC4:             ; ; Constructor 
00000BC4:             ;  ; Set up Stack pointer 
00000BC4: E28FDF93    ;     ADRL    SP, Terminal_Handler_Stack_End
00000BC8:             ; 
00000BC8:             ;  ; Set up Buffer to store input from buffer 
00000BC8: E28FCF92    ;     ADRL    R12, StandardIn_start
00000BCC:             ;  ; Saves memeory address to process register 
00000BCC: E1A0000C    ;     MOV     R0, R12
00000BD0: E3A01040    ;     MOV     R1, #&40
00000BD4: EF000B14    ;     SVC     buffer_initialise
00000BD8:             ; 
00000BD8:             ; ; Request that Interrupt for when something is received in RxD 
00000BD8:             ;     ; Set up reciever interrupt 
00000BD8: E3A00010    ;     MOV     R0, #Interrupt_Receiver
00000BDC: EF000000    ;     SVC     Interrupt_Set_SVC
00000BE0:             ; 
00000BE0:             ; 
00000BE0:             ; ;
00000BE0:             ; ; Main 
00000BE0:             ;  ; Set up Constants 
00000BE0: E24FBFB2    ;     ADRL     R11, Serial_RxD_Buffer_Address 
00000BE4: E24BBB02    ; 
00000BE8: E3A0A001    ;     MOV     R10, #1
00000BEC:             ;     ;MOV     R10, #Terminal_Control
00000BEC:             ;     ;MOV     R9, #Terminal_Data
00000BEC:             ; 
00000BEC:             ;  ;
00000BEC:             ;  ; Second it needs to handler what happens when it is called 
00000BEC:             ; Terminal_Handler_Main_Loop
00000BEC:             ;   ; Requests control of RxD and TxD 
00000BEC:             ;   ; XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
00000BEC:             ;   ; 
00000BEC:             ;   ; Check if there is anything in the RxD Buffer 
00000BEC: E1A0000B    ;     MOV     R0, R11 
00000BF0: EBFFFFE2    ;     BL      buffer_get
00000BF4: E3500000    ;     CMP     R0, #&0
00000BF8: 0AFFFFFB    ;     BEQ     Terminal_Handler_Main_Loop
00000BFC:             ; 
00000BFC:             ;   ;
00000BFC:             ;   ; Check if in protected mode 
00000BFC: E3580001    ;     CMP     R8, #1
00000C00: 0B000001    ;     BLEQ     Transmit 
00000C04:             ;   ;
00000C04:             ;   ; Check if the input is an Enter
00000C04: E350000A    ;     CMP     R0, #&A
00000C08: 0AFFFFFF    ;     BEQ     Terminal_Handler_Commands
00000C0C:             ;     ;   if it is an enter check if it is a known command 
00000C0C:             ;         ; Checks if it has recieved a input from the serie line 
00000C0C:             ; 
00000C0C:             ;     ; Checks to see what the input is and if it shoudl do anyting 
00000C0C:             ;     ;   if it is enter it checks what it needs to do 
00000C0C:             ;     ; Places input into StandardIn Buffer 
00000C0C:             ;     ; Checks to see if it is in echo to terminal mode or not 
00000C0C:             ;     ;   If it is it send it to TxD Buffer 
00000C0C:             ; 
00000C0C:             ; Transmit 
00000C0C:             ; ; This function is responsible for transmitting 
00000C0C:             ; 
00000C0C:             ; Terminal_Handler_Commands
00000C0C:             ;     ; This function will check input against commands 
00000C0C:             ; 
00000C0C:             ; Terminal_Handler_Commands_Table 
00000C0C: 00000C10    ;                                 DEFW Command_Echo
00000C10:             ; Terminal_Handler_Commands_Table_End
00000C10:             ; 
00000C10: 65 63 68 6F ; Command_Echo DEFB "echo",0
00000C14: 00          ; 
00000C15:             ; 
00000C15:             ; 
00000C15:             ; ; Temp permanent memeory for user processes 
00000C15:             ; GET user_memory.s
00000C15:             ; 
00000C15:             ; ; variable for different stacks 
00000C15:             ; Terminal_Handler_Stack_Size EQU &200
00000C18:             ;     Align 
00000C18:             ; StandardIn_Buffer_Size      EQU &64
00000C18:             ;     Align
00000C18:             ;         ; Terminal Handler Stack 
00000C18:             ;         
00000C18:             ;         Terminal_Handler_Stack_Start   DEFS Terminal_Handler_Stack_Size ; Terminal_Handler Stac
                      ; k
00000E18:             ;         Terminal_Handler_Stack_End
00000E18:             ;              Align
00000E18:             ; 
00000E18:             ;         StandardIn_start DEFS StandardIn_Buffer_Size
00000E7C:             ;         StandardIn_End 
00000E7C:             ;             Align 

Symbol Table: Labels
: Undefined_Instruction             00000004  Local -- ARM
: Prefetch_Abort                    0000000C  Local -- ARM
: Data_Abort                        00000010  Local -- ARM
: Not_Provided_Except               00000014  Local -- ARM
: Fast_Interrupt_Request            0000001C  Local -- ARM
: Initialise_Program                00000020  Local -- ARM
: SVC_Handler                       00000024  Local -- ARM
: SVC_Jump_Table_Size               00000008  Value
: SVC_Jump_Table                    0000004C  Local -- ARM
: SVC_Jump_Table_End                00000054  Local -- ARM
: SVC_Jump_Table_place_holder       00000054  Local -- ARM
: SVC_Out_Of_Bounds                 00000054  Local -- ARM
: IRQ_Handler                       00000058  Local -- ARM
: IRQ_RxD                           00000070  Local -- ARM
: kernal_Initialise                 00000098  Local -- ARM
: IRQ_Mode                          00000012  Value
: Super_Mode                        00000013  Value
: System_Mode_Bit_Mask              0000001F  Value
: Interrupt_Receiver                00000010  Value
: Interrupt_Transmit                00000020  Value
: Interrupt_Alert_Offset            00000018  Value
: Port_Area                         10000000  Value
: Interrupt_Active_Offset           0000001C  Value
: Serial_RxD_Buffer_Address         00000120  Local -- ARM
: Serial_TxD_Buffer_Address         00000136  Local -- ARM
: Supervisor_Stack_Size             00000256  Value
: Interrupt_Stack_Size              00000256  Value
: Supervisor_Stack_Start            0000014C  Local -- ARM
: Supervisor_Stack_End              000003A2  Local -- ARM
: Interrupt_Stack_Start             000003A4  Local -- ARM
: Interrupt_Stack_End               000005FA  Local -- ARM
: Serial_RxD_Buffer_Size            00000256  Value
: Serial_TxD_Buffer_Size            00000256  Value
: Serial_RxD_Buffer_Start           000005FC  Local -- ARM
: Serial_RxD_Buffer_End             00000852  Local -- ARM
: Serial_TxD_Buffer_Start           00000854  Local -- ARM
: Serial_TxD_Buffer_End             00000AAA  Local -- ARM
: Interrupt_Set                     00000AAC  Local -- ARM
: Interrupt_Off                     00000AC0  Local -- ARM
: Transmit_word                     00000AD4  Local -- ARM
: Transmit_word_send                00000B08  Local -- ARM
: Interrupt_Set_SVC                 00000000  Value
: Interrupt_Off_SVC                 00000004  Value
: Terminal_Data                     00000010  Value
: Terminal_Control                  00000014  Value
: buffer_start                      00000000  Offset
: buffer_end                        00000004  Offset
: buffer_head                       00000008  Offset
: buffer_tail                       0000000C  Offset
: buffer_waiter                     00000010  Offset
: buffer_initialise                 00000B14  Local -- ARM
: buffer_put                        00000B38  Local -- ARM
: buffer_full                       00000B7C  Local -- ARM
: buffer_get                        00000B80  Local -- ARM
: buffer_empty                      00000BB0  Local -- ARM
: pointer_next                      00000000  Offset
: process_id                        00000004  Offset
: process_stack_pointer             00000008  Offset
: process_constructor               0000000C  Offset
: Terminal_Handler_Process          00000BB4  Local -- ARM
: Terminal_Handler_Constructor      00000BC4  Local -- ARM
: Terminal_Handler_Main_Loop        00000BEC  Local -- ARM
: Transmit                          00000C0C  Local -- ARM
: Terminal_Handler_Commands         00000C0C  Local -- ARM
: Terminal_Handler_Commands_Table   00000C0C  Local -- ARM
: Terminal_Handler_Commands_Table_  00000C10  Local -- ARM
: Command_Echo                      00000C10  Local -- ARM
: Terminal_Handler_Stack_Size       00000200  Value
: StandardIn_Buffer_Size            00000064  Value
: Terminal_Handler_Stack_Start      00000C18  Local -- ARM
: Terminal_Handler_Stack_End        00000E18  Local -- ARM
: StandardIn_start                  00000E18  Local -- ARM
: StandardIn_End                    00000E7C  Local -- ARM
